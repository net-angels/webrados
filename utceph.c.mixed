#include "utceph.h"
#include "protos.h"
#include <fcgiapp.h>
static int raw_workers_cnt = 0;

ssize_t Readline(int sockd, void *vptr, size_t maxlen) {
    ssize_t n, rc;
    char c, *buffer;

    buffer = vptr;

    for (n = 1; n < maxlen; n++) {

        if ((rc = read(sockd, &c, 1)) == 1) {
            *buffer++ = c;
            if (c == '\n')
                break;
        } else if (rc == 0) {
            if (n == 1)
                return 0;
            else
                break;
        } else {
            if (errno == EINTR)
                continue;
            return -1;
        }
    }

    *buffer = 0;
    return n;
}

/*  Write a line to a socket  */
ssize_t Writeline(int sockd, const void *vptr, size_t n) {
    size_t nleft;
    ssize_t nwritten;
    const char *buffer;

    buffer = vptr;
    nleft = n;

    while (nleft > 0) {
        if ((nwritten = write(sockd, buffer, nleft)) <= 0) {
            if (errno == EINTR)
                nwritten = 0;
            else
                return -1;
        }
        nleft -= nwritten;
        buffer += nwritten;
    }

    return n;
}

ssize_t WritelineF(int sockd, const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    char buf[1024];
    memset(buf, '\0', 1024);
    vsnprintf(buf, 1024, fmt, args);
    return Writeline(sockd, buf, strlen(buf));
}

int create_and_bind2() {
    int sock_fd = 0;
    if (0 != strcmp(globals.socket, "")) {

        int fd = open(globals.socket, O_CREAT, 0644);
        if (fd < 0) {
            int err = errno;
            if (err != ENXIO) {
                logger("Error: %s", strerror(errno));
                halt();
            }
        } else {
            close(fd);
        }

        sock_fd = FCGX_OpenSocket(globals.socket, SOMAXCONN);
        if (sock_fd < 0) {
            logger("Error: %s", strerror(errno));
            halt();
        }
        if (chmod(globals.socket, 0777) < 0) {
            logger("Error: %s", strerror(errno));
        }
    } else if (NULL != strstr(globals.socket, ":")) {
        sock_fd = FCGX_OpenSocket(globals.socket, SOMAXCONN);
        if (sock_fd < 0) {
            logger("Error: %s", strerror(errno));
            halt();
        }
    }
    return sock_fd;
}

int create_and_bind(char *socket_path) {

    int fd;
    bool us = false;
    struct sockaddr_un address;
    if (NULL == socket_path || 0 == strcmp(socket_path, "")) {
        return -1;
    }
    if (NULL == strstr(socket_path, ":")) {
        int h;
        if (0 < (h = open(globals.socket, O_RDONLY))) {
            close(h);
            unlink(globals.socket);
        }
        address.sun_family = AF_UNIX;
        strcpy(address.sun_path, socket_path);
        chmod(address.sun_path, 0777);
        fd = socket(AF_UNIX, SOCK_STREAM, 0);
        us = true;
    } else {
        char *addr = strtok(socket_path, ":");
        if (addr) {
            char *port = strtok(NULL, ":");
            fd = socket(AF_INET, SOCK_STREAM, 0);
            bzero(&servaddr, sizeof (servaddr));
            servaddr.sin_family = AF_INET;
            servaddr.sin_addr.s_addr = inet_addr(addr);
            servaddr.sin_port = htons(atoi(port));
        } else {
            logger("%s", "Invalid socket address/path");
            return -1;
        }
    }
    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof (yes)) < 0) {
        logger("SETSOCKOPT(): %s", strerror(errno));
        halt();
    }

    if (us) {
        if (0 != bind(fd, (struct sockaddr*) (&address), sizeof (address))) {
            logger("Can not bind on %s: %s", globals.socket, strerror(errno));
            halt();
        }
    } else {
        if (0 != bind(fd, (struct sockaddr *) &servaddr, sizeof (servaddr))) {
            logger("Can not bind on %s: %s", globals.socket, strerror(errno));
            halt();
        }
    }


    return fd;
}

int main(int argc, char **argv) {
    static bool ctr = true;
    FCGX_Request request;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    set_sig_handler();
    open_log();
    logger("Starting application\n");
    allocate_resources();

    read_config(config_file);
    FCGX_Init();

    /* Buffer where events are returned */
    events = calloc(globals.threads_count, sizeof event);

    listenfd = create_and_bind2();

    fcntl(listenfd, F_SETFL, fcntl(listenfd, F_GETFD, 0) | O_NONBLOCK | O_ASYNC);

    if (-1 == listen(listenfd, globals.threads_count)) {
        logger("Can not listen on %s: %s", globals.socket, strerror(errno));
        halt();
    }


    efd = epoll_create(globals.threads_count);
    if (-1 == efd) {
        logger("Error with epoll initialization: - %s", strerror(errno));
        halt();
    }
    //
    event.data.fd = listenfd;
    event.events = EPOLLIN | EPOLLPRI | EPOLLERR | EPOLLHUP;
    //
    if (-1 == epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &event)) {
        logger("Error with epoll_ctl: - %s", strerror(errno));
        halt();
    }

    //

    while (!listen_stop_flag) {
        int n, i;
        n = epoll_wait(efd, events, globals.threads_count, epolltimeout);
        for (i = 0; i < n; i++) {
            if (listenfd == events[i].data.fd) {

                in_len = sizeof in_addr;
                FCGX_InitRequest(&request, listenfd, 0);

                int rc = FCGX_Accept_r(&request);
                if (rc < 0) {
                    logger("Can not accept: %s", strerror(errno));
                    continue;
                }

                if (raw_workers_cnt == globals.threads_count) {
                     FCGX_FPrintF(request.out,"%s", ierror);
                    logger("You are about to reach max-worker[%d] limit. Will drop connection", globals.threads_count);
                    close(connfd);
                    continue;
                }


                event.data.fd = connfd;
                event.events = EPOLLIN | EPOLLPRI | EPOLLERR | EPOLLHUP;

                if (0 > epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &event)) {
                     FCGX_FPrintF(request.out,"%s", ierror);
                    logger("Error with epoll_ctl: - %s", strerror(errno));
                    continue;
                }
                //
                fill_current_data();
                if (NULL == current_data.poolname || NULL == current_data.filename || (0 == strcmp(current_data.poolname, "")) || (0 == strcmp(current_data.filename, ""))) {
                    Writeline(connfd, usage, strlen(usage));
                    logger("No parameters given\n");
                    ctr = false;
                    continue;
                } else {
                    ctr = true;
                }

                if (!is_whitelisted(current_data.poolname)) {
                    logger("Pool '%s' is not whitelisted\n", current_data.poolname);
                    Writeline(connfd, forbidden, strlen(forbidden));
                    continue;
                }
                if (current_data.cLength <= 0 && (0 != strcmp("GET", current_data.method))&& (0 != strcmp("POST", current_data.method))) {
                    Writeline(connfd, no_data, strlen(no_data));
                    logger("No data from standard input\n");
                } else {
                    if (ctr) {
                        logger("Spawning thread [%d]\n", raw_workers_cnt);
                        memset(req_pass.filename, '\0', sizeof (req_pass.filename));
                        memset(req_pass.poolname, '\0', sizeof (req_pass.poolname));
                        memset(req_pass.method, '\0', sizeof (req_pass.method));
                        //
                        req_pass.no = raw_workers_cnt;
                        req_pass.clen = current_data.cLength;
                        req_pass.connfd = connfd;
                        strncpy(req_pass.filename, current_data.filename, strlen(current_data.filename));
                        strncpy(req_pass.poolname, current_data.poolname, strlen(current_data.poolname));
                        strncpy(req_pass.method, current_data.method, strlen(current_data.method));

                        if (0 == pthread_create(&id[raw_workers_cnt], &attr, doit, &req_pass)) {
                            raw_workers_cnt++;
                        } else {
                            logger("Cannot create a thread: %s", strerror(errno));
                        }
                    }
                }


                //
            } /* if listenfd */
        } /* for */
        //usleep(10);
    } /* while */

    free(events);
    close(listenfd);
    halt();
    return 0;
}

void halt() {
    int h;
    logger("Closing application\n");
    listen_stop_flag = true;

    if (0 < (h = open(globals.socket, O_RDONLY))) {
        close(h);
        unlink(globals.socket);
    }

    free_resources();
    close_log();
    exit(EXIT_SUCCESS);
}

void *doit(void *ptr) {

    if (NULL == ptr) {
        logger("Empty data for thread\n");
        pthread_exit((void *) 0);
    }
    pid_t tid = syscall(__NR_gettid);
    static pthread_mutex_t write_mutex = PTHREAD_MUTEX_INITIALIZER;
    static pthread_mutex_t read_mutex = PTHREAD_MUTEX_INITIALIZER;
    static pthread_mutex_t counter_mutex = PTHREAD_MUTEX_INITIALIZER;

    set_thread_signalmask(ths);
    req_params *req = (req_params *) ptr;
    pthread_detach(pthread_self());
    if (errno == 0) {
        logger("[%d] Detached with tid: %d", req->no, tid);
    }

    logger("[%d] %s %s %s %d %ld", tid, req->filename, req->method, req->poolname, req->no, req->clen);

    rados_ioctx_t io;
    rados_t cluster;

    int err = rados_create(&cluster, NULL);
    if (err < 0) {
        logger("[%d] Cannot create a cluster handle: %s\n", tid, strerror(-err));
        halt();
    }

    err = rados_conf_read_file(cluster, ceph_config);
    if (err < 0) {
        logger("[%d] Cannot read config file: %s\n", tid, strerror(-err));
        halt();
    }

    err = rados_connect(cluster);
    if (err < 0) {
        logger("[%d] Cannot connect to cluster: %s\n", tid, strerror(-err));
        halt();
    }

    err = rados_ioctx_create(cluster, req->poolname, &io);

    if (err < 0) {
        logger("[%d] Cannot open rados pool [%s]: %s\n", tid, req->poolname, strerror(-err));
        //FCGX_FPrintF(req->request.out, "Cannot open rados pool [%s]: %s\n", req->poolname, strerror(-err));
        goto end;
    }

    if (0 == strcmp(req->method, "PUT")) {
        logger("[%d] Expecting %d bytes\n", tid, req->clen);
        logger("[%d] Writing to [%s -> %s]\n", tid, req->poolname, req->filename);

        pthread_mutex_lock(&write_mutex);
        uint64_t bytes = PUT(io, req->connfd, req->filename, req->clen);
        logger("[%d] Upload completed: %s has %d bytes\n", tid, req->filename, bytes);
        if (0 >= bytes) {
            WritelineF(req->connfd, "Connection: Close\r\n\r\n");
        } else {
            WritelineF(req->connfd, "%s", created);
        }
        pthread_mutex_unlock(&write_mutex);
    }/* if PUT */
    else if (0 == strcmp(req->method, "GET")) {
        pthread_mutex_lock(&read_mutex);
        uint64_t bytes = GET(io, req->connfd, current_data.filename);
        logger("[%d] Downloaded: %ld bytes\n", tid, bytes);
        if (0 >= bytes) {
            WritelineF(req->connfd, "Connection: Close\r\n\r\n");
        }
        pthread_mutex_unlock(&read_mutex);

    } else {
        logger("[%d] Method %s not supported\n", tid, req->method);
        WritelineF(req->connfd, "%s", not_supported);
        goto end;
    }
end:
    logger("[%d] Destroying IO\n", tid);
    if (io != NULL) {
        rados_ioctx_destroy(io);
    }

    logger("[%d] Shutting down cluster\n", tid);
    if (cluster != NULL) {
        rados_shutdown(cluster);
    }
    pthread_mutex_lock(&counter_mutex);
    logger("[%d] Exiting thread [%d]\n", tid, req->no);
    if (raw_workers_cnt > 0)raw_workers_cnt--;
    pthread_mutex_unlock(&counter_mutex);

    pthread_exit((void *) 0);
}

void set_thread_signalmask(sigset_t SignalSet) {

    sigemptyset(&SignalSet);
    sigaddset(&SignalSet, SIGHUP);
    sigaddset(&SignalSet, SIGUSR1);
    sigaddset(&SignalSet, SIGUSR2);
    sigaddset(&SignalSet, SIGTRAP);
    sigaddset(&SignalSet, SIGCHLD);
    sigaddset(&SignalSet, SIGTSTP);
    sigaddset(&SignalSet, SIGTTOU);
    sigaddset(&SignalSet, SIGTTIN);
    sigaddset(&SignalSet, SIGABRT);
    sigaddset(&SignalSet, SIGPIPE);
    sigaddset(&SignalSet, SIGALRM);
    sigaddset(&SignalSet, SIGSEGV);
    sigaddset(&SignalSet, SIGBUS);

    pthread_sigmask(SIG_BLOCK, &SignalSet, NULL);
}

void fill_current_data() {

    char *duplicate = NULL;
    char *p = NULL;

    memset(current_data.poolname, '\0', 32);
    memset(current_data.filename, '\0', 256);
    memset(current_data.method, '\0', 8);
    memset(current_data.requri, '\0', 256);
    current_data.cLength = 0;

    char *contentLength = getenv("CONTENT_LENGTH");
    char *rmethod = getenv("REQUEST_METHOD");
    char *requri = getenv("REQUEST_URI");

    logger("M:%s,U:%s", rmethod, requri);
    if (contentLength != NULL) {
        current_data.cLength = strtol(contentLength, NULL, 10);
    } else {
        current_data.cLength = 0;
    }

    if (rmethod != NULL) {
        snprintf(current_data.method, sizeof (current_data.method) - 1, "%s", rmethod);
    }

    if (requri != NULL) {
        snprintf(current_data.requri, sizeof (current_data.method) - 1, "%s", requri);
    } else {
        return;
    }

    duplicate = strndup(requri, strlen(requri));

    if (NULL == duplicate) {
        logger("Error: %s\n", strerror(errno));
        return;
    }
    p = strtok(duplicate, "/");
    if (p) {
        strncpy(current_data.poolname, p, (-1 + sizeof (current_data.poolname)));
    }

    int z = 0, remains = 0;

    strncat(current_data.filename, "/", 1);
    while (NULL != (p = strtok(NULL, "/"))) {
        z = strlen(p);
        remains = 254 - strlen(current_data.filename);
        if (z > remains)z = remains;
        strncat(current_data.filename, p, z);
        if (remains > 0) {
            strncat(current_data.filename, "/", 1);
        }
    }
    int filename_sz = strlen(current_data.filename);
    if (current_data.filename[filename_sz - 1] == '/') {
        current_data.filename[filename_sz - 1] = '\0';
    }
    int i = 0, count = 0;

    for (i = 0; i < filename_sz; i++) {
        if (current_data.filename[i] == '/') {
            count++;
        }
    }
    if (count == 1) {
        for (i = 0; i < filename_sz && current_data.filename[i] != '\0'; i++) {
            current_data.filename[i] = current_data.filename[i + 1];
        }
        for (; i < filename_sz; i++)
            current_data.filename[i] = '\0';

    }
    if (duplicate)FREE(duplicate);
    if (p)FREE(p);
    contentLength = NULL;
    rmethod = NULL;
    requri = NULL;

}