#include "utceph.h"
#include "protos.h"

static int thread_counter = 0;

int main(int argc, char **argv) {
    static bool ctr = true;

    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    set_sig_handler();
    open_log();
    logger("Starting application\n");
    allocate_resources();

    read_config(config_file);
    FCGX_Init();

    int sock_fd = 0;
    if (0 != strcmp(globals.socket, "")) {

        int fd = open(globals.socket, O_CREAT, 0644);
        if (fd < 0) {
            int err = errno;
            if (err != ENXIO) {
                logger("Error: %s", strerror(errno));
                halt();
            }
        } else {
            close(fd);
        }

        sock_fd = FCGX_OpenSocket(globals.socket, SOMAXCONN);
        if (sock_fd < 0) {
            logger("Error: %s", strerror(errno));
            halt();
        }
        if (chmod(globals.socket, 0777) < 0) {
            logger("Error: %s", strerror(errno));
        }
    } else if (NULL != strstr(globals.socket, ":")) {
        sock_fd = FCGX_OpenSocket(globals.socket, SOMAXCONN);
        if (sock_fd < 0) {
            logger("Error: %s", strerror(errno));
            halt();
        }
    }
    fcntl(0, F_SETFL, fcntl(0, F_GETFD, 0) | O_NONBLOCK | O_ASYNC);
    //

    //request = xcalloc(globals.threads_count, sizeof (FCGX_Request));
    //int f;
    //for (f = 0; f < globals.threads_count; f++) {
    //    FCGX_InitRequest(&request[f], sock_fd, 0);
    //    //logger("F = %d: in:%p,out:%p",f,request[f].in,request[f].out);
    // }

    for (;;) {
        if (thread_counter == globals.threads_count) {
            logger("Max amount of threads(%d) reached\n", globals.threads_count);
            continue;
        }
        FCGX_InitRequest(&request, sock_fd, 0);
        int rc = FCGX_Accept_r(&request);

        if (rc < 0) {
            if ((errno == EAGAIN) || (errno == EWOULDBLOCK)) {
                continue;
            } else {
                logger("Error: %s\n", strerror(errno));
                continue;
            }

        }
        //logger("RC: %d,%p,%d", rc, &request[thread_counter].out, thread_counter);
        logger("F = %d: in:%p,out:%p", thread_counter, &request.in, &request.out);

        fill_current_data(&request);

        if (NULL == current_data.poolname || NULL == current_data.filename || (0 == strcmp(current_data.poolname, "")) || (0 == strcmp(current_data.filename, ""))) {
            FCGX_FPrintF(request.out, "Content-type: text/html\r\n\r\n");
            FCGX_FPrintF(request.out, "No parameters given<br />\n");
            FCGX_FPrintF(request.out, "Request method: %s<br />\n", current_data.method);
            FCGX_FPrintF(request.out, "Upload: curl -XPUT -T filename http://uploadhost.com/poolname/filename<br />\n");
            FCGX_FPrintF(request.out, "Download: curl -XGET http://uploadhost.com/poolname/filename\n");
            FCGX_FFlush(request.out);
            logger("No parameters given\n");
            ctr = false;
            continue;
        } else {
            ctr = true;
        }

        if (!is_whitelisted(current_data.poolname)) {
            logger("Pool '%s' is not whitelisted\n", current_data.poolname);
            FCGX_FPrintF(request.out, "%s", forbidden);
            continue;
        }

        if (current_data.cLength <= 0 && (0 != strcmp("GET", current_data.method))&& (0 != strcmp("POST", current_data.method))) {
            FCGX_FPrintF(request.out, "Content-type: text/html\r\n\r\n");
            FCGX_FPrintF(request.out, "No data from standard input\n");
            logger("No data from standard input\n");
        } else {
            if (ctr) {


                logger("Spawning thread [%d]\n", thread_counter);

                memset(req_pass.filename, '\0', sizeof (req_pass.filename));
                memset(req_pass.poolname, '\0', sizeof (req_pass.poolname));
                memset(req_pass.method, '\0', sizeof (req_pass.method));
                //
                req_pass.no = thread_counter;
                req_pass.clen = current_data.cLength;
                strncpy(req_pass.filename, current_data.filename, strlen(current_data.filename));
                strncpy(req_pass.poolname, current_data.poolname, strlen(current_data.poolname));
                strncpy(req_pass.method, current_data.method, strlen(current_data.method));
                req_pass.request = request;

                if (0 == pthread_create(&id[thread_counter], &attr, doit, &req_pass)) {
                    thread_counter++;
                }
            }
        } /* else */

    } /* for */

    halt();
    return 0;
}

void halt() {
    logger("Closing application\n");
    FCGX_ShutdownPending();
    FCGI_Finish();
    free_resources();
    close_log();
    exit(EXIT_SUCCESS);
}

void *doit(void *ptr) {

    if (NULL == ptr) {
        logger("Empty data for thread\n");
        pthread_exit((void *) 0);
    }
    pid_t tid = syscall(__NR_gettid);
    static pthread_mutex_t write_mutex = PTHREAD_MUTEX_INITIALIZER;
    static pthread_mutex_t read_mutex = PTHREAD_MUTEX_INITIALIZER;
    static pthread_mutex_t counter_mutex = PTHREAD_MUTEX_INITIALIZER;

    set_thread_signalmask(ths);
    req_params *req = (req_params *) ptr;
    pthread_detach(pthread_self());
    if (errno == 0) {
        logger("[%d] Detached with tid: %d", req->no, tid);
    }

    // logger("[%d] %s %s %s %d %ld", tid, req->filename, req->method, req->poolname, req->no, req->clen);
    //req->request = treqs[req->no];
    rados_ioctx_t io;
    rados_t cluster;

    int err = rados_create(&cluster, NULL);
    if (err < 0) {
        logger("[%d] Cannot create a cluster handle: %s\n", tid, strerror(-err));
        halt();
    }

    err = rados_conf_read_file(cluster, ceph_config);
    if (err < 0) {
        logger("[%d] Cannot read config file: %s\n", tid, strerror(-err));
        halt();
    }

    err = rados_connect(cluster);
    if (err < 0) {
        logger("[%d] Cannot connect to cluster: %s\n", tid, strerror(-err));
        halt();
    }

    err = rados_ioctx_create(cluster, req->poolname, &io);

    if (err < 0) {
        logger("[%d] Cannot open rados pool [%s]: %s\n", tid, req->poolname, strerror(-err));
        FCGX_FPrintF(req->request.out, "Cannot open rados pool [%s]: %s\n", req->poolname, strerror(-err));
        goto end;
    }

    if (0 == strcmp(req->method, "PUT")) {
        logger("[%d] Expecting %d bytes\n", tid, req->clen);
        logger("[%d] Writing to [%s -> %s]\n", tid, req->poolname, req->filename);

        pthread_mutex_lock(&write_mutex);
        uint64_t bytes = PUT(io, &req->request, req->filename, req->clen);
        logger("[%d] Upload completed: %s has %d bytes\n", tid, req->filename, bytes);
        if (0 >= bytes) {
            FCGX_FPrintF(req->request.out, "Connection: Close\r\n\r\n");
        } else {
            FCGX_FPrintF(req->request.out, "%s", created);
        }
        pthread_mutex_unlock(&write_mutex);
    }/* if PUT */
    else if (0 == strcmp(req->method, "GET")) {
        pthread_mutex_lock(&read_mutex);
        uint64_t bytes = GET(io, &req->request, current_data.filename);
        logger("[%d] Downloaded: %ld bytes\n", tid, bytes);
        if (0 >= bytes) {
            FCGX_FPrintF(req->request.out, "Connection: Close\r\n\r\n");
        }
        pthread_mutex_unlock(&read_mutex);

    } else {
        logger("[%d] Method %s not supported\n", tid, req->method);
        FCGX_FPrintF(req->request.out, "%s", not_supported);
        goto end;
    }
end:
    FCGX_Finish_r(&req->request);
    logger("[%d] Destroying IO\n", tid);
    if (io != NULL) {
        rados_ioctx_destroy(io);
    }

    logger("[%d] Shutting down cluster\n", tid);
    if (cluster != NULL) {
        rados_shutdown(cluster);
    }
    pthread_mutex_lock(&counter_mutex);
    logger("[%d] Exiting thread [%d]\n", tid, req->no);
    if (thread_counter > 0)thread_counter--;
    pthread_mutex_unlock(&counter_mutex);

    pthread_exit((void *) 0);
}

void set_thread_signalmask(sigset_t SignalSet) {

    sigemptyset(&SignalSet);
    sigaddset(&SignalSet, SIGHUP);
    sigaddset(&SignalSet, SIGUSR1);
    sigaddset(&SignalSet, SIGUSR2);
    sigaddset(&SignalSet, SIGTRAP);
    sigaddset(&SignalSet, SIGCHLD);
    sigaddset(&SignalSet, SIGTSTP);
    sigaddset(&SignalSet, SIGTTOU);
    sigaddset(&SignalSet, SIGTTIN);
    sigaddset(&SignalSet, SIGABRT);
    sigaddset(&SignalSet, SIGPIPE);
    sigaddset(&SignalSet, SIGALRM);
    sigaddset(&SignalSet, SIGSEGV);
    sigaddset(&SignalSet, SIGBUS);

    pthread_sigmask(SIG_BLOCK, &SignalSet, NULL);
}

void fill_current_data(FCGX_Request *r) {

    char *duplicate = NULL;
    char *p = NULL;

    memset(current_data.poolname, '\0', 32);
    memset(current_data.filename, '\0', 256);
    memset(current_data.method, '\0', 8);
    memset(current_data.requri, '\0', 256);
    current_data.cLength = 0;

    logger("--> %s", r->envp[0]);

    char *contentLength = FCGX_GetParam("CONTENT_LENGTH", r->envp);
    char *rmethod = FCGX_GetParam("REQUEST_METHOD", r->envp);
    char *requri = FCGX_GetParam("REQUEST_URI", r->envp);

    if (contentLength != NULL) {
        current_data.cLength = strtol(contentLength, NULL, 10);
    } else {
        current_data.cLength = 0;
    }

    if (rmethod != NULL) {
        snprintf(current_data.method, sizeof (current_data.method) - 1, "%s", rmethod);
    }

    if (requri != NULL) {
        snprintf(current_data.requri, sizeof (current_data.method) - 1, "%s", requri);
    } else {
        return;
    }

    duplicate = strndup(requri, strlen(requri));

    if (NULL == duplicate) {
        logger("Error: %s\n", strerror(errno));
        return;
    }
    p = strtok(duplicate, "/");
    if (p) {
        strncpy(current_data.poolname, p, (-1 + sizeof (current_data.poolname)));
    }

    int z = 0, remains = 0;

    strncat(current_data.filename, "/", 1);
    while (NULL != (p = strtok(NULL, "/"))) {
        z = strlen(p);
        remains = 254 - strlen(current_data.filename);
        if (z > remains)z = remains;
        strncat(current_data.filename, p, z);
        if (remains > 0) {
            strncat(current_data.filename, "/", 1);
        }
    }
    int filename_sz = strlen(current_data.filename);
    if (current_data.filename[filename_sz - 1] == '/') {
        current_data.filename[filename_sz - 1] = '\0';
    }
    int i = 0, count = 0;

    for (i = 0; i < filename_sz; i++) {
        if (current_data.filename[i] == '/') {
            count++;
        }
    }
    if (count == 1) {
        for (i = 0; i < filename_sz && current_data.filename[i] != '\0'; i++) {
            current_data.filename[i] = current_data.filename[i + 1];
        }
        for (; i < filename_sz; i++)
            current_data.filename[i] = '\0';

    }
    if (duplicate)FREE(duplicate);
    if (p)FREE(p);
    contentLength = NULL;
    rmethod = NULL;
    requri = NULL;

}